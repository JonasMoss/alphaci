#' Calculate the capital pi matrix.
#'
#' The capital pi matrix is multiplied element-wise with the asymptotic
#'    covariance matrix of s to correct for missing values.
#'
#' @param p Vector of probabilities for being missing.
#' @param vech If `TRUE`, returns for the result for half-vectorization.
#' @return The capital pi matrix.
pi_mat <- function(p, vech = TRUE) {
  r <- length(p)
  if (vech) {
    m <- (r * (r + 1)) / 2
    temp_mat <- matrix(rep(seq(r), r), nrow = r)
    ri <- c(matrixcalc::vech(temp_mat))
    ci <- c(matrixcalc::vech(t(temp_mat)))
  } else {
    m <- r^2
    temp_mat <- matrix(rep(1:r, r), nrow = r)
    ri <- c(matrixcalc::vec(temp_mat))
    ci <- c(matrixcalc::vec(t(temp_mat)))
  }
  outer(seq(m), seq(m), Vectorize(function(i, j) {
    numbers <- c()
    for (k in c(i, j)) {
      numbers <- c(numbers, ri[k])
      if (ri[k] != ci[k]) numbers <- c(numbers, ci[k])
    }
    table <- Rfast::Table(numbers)
    1 / prod(p[as.numeric(names(table))[table >= 2]])
  }))
}

#' Calculate the theoretical gamma matrix.
#'
#' The theoretical gamma matrix is the covariance matrix of the covariances.
#' This function assumes multivariate normality of the xs.
#'
#' @param sigma Covariance matrix
#' @param vech If `TRUE`, returns for the result for half-vectorization.
gamma_mat <- function(sigma, vech = TRUE) {
  r <- nrow(sigma)
  e_mat <- matrixcalc::elimination.matrix(r)
  k_mat <- matrixcalc::commutation.matrix(r)
  gamma <- (diag(r^2) + k_mat) %*% (sigma %x% sigma)
  if (vech) e_mat %*% gamma %*% t(e_mat) else gamma
}

#' Get the indices of the diagonal for the variances.
#' @param r Number of raters.
#' @param vech If `TRUE`, returns for the result for half-vectorization.
#' @return A vector of `TRUE` where the variances are.
get_diag_indices <- function(r, vech = TRUE) {
  e_mat <- matrixcalc::elimination.matrix(r)
  indices <- rep(0, r^2)
  indices[c(1, (r + 1) * (1:(r - 1)) + 1)] <- 1
  if (vech) c(e_mat %*% indices) else c(indices)
}

#' The covariance matrix of the elements involved in the inference.
#'
#' Returns the covariance matrix of x, y, z as defined in the paper.
#'
#' @param p Vector of probabilities for being missing.
#' @param mu Vector of means.
#' @param sigma Covariance matrix
#' @param gamma Covariance matrix of the covariances. Defaults to the
#'    one implied by normality.
#' @return The covariance matrix of x, y, z
#' @keywords internal
cov_mat <- function(p, mu, sigma, gamma = NULL) {
  if (is.null(gamma)) {
    gamma <- gamma_mat(sigma, vech = FALSE)
  }

  r <- length(p)
  # The covariances involving s.
  gamma_pi <- gamma * pi_mat(p, vech = FALSE)
  d <- get_diag_indices(r, vech = FALSE)
  ones <- rep(1, r^2)
  ones_minus_d <- ones - d
  cov_ss_ss <- t(ones_minus_d) %*% (gamma_pi) %*% ones_minus_d
  cov_ss_tr <- t(ones_minus_d) %*% (gamma_pi) %*% d
  cov_tr_tr <- t(d) %*% gamma_pi %*% d

  # The variance of mean(mu^2) - mean(mu)^2
  p_mat <- diag(1 / p)
  mu_middle <- (sigma + (p_mat - diag(r)) * diag(sigma))
  mu_vec <- (diag(r) - matrix(1 / r, r, r)) %*% mu
  cov_mu_mu <- c(4 / r^2 * t(mu_vec) %*% mu_middle %*% mu_vec)
  matrix(c(
    cov_ss_ss, cov_ss_tr, 0,
    cov_ss_tr, cov_tr_tr, 0,
    0, 0, cov_mu_mu
  ), nrow = 3, byrow = FALSE)
}

#' Asymptotic variance for the kappas.
#'
#' @param mat Covariance matrix as calculated by `cov_mat`.
#' @param mu Vector of means.
#' @param sigma Covariance matrix
#' @param type Either `"cohen"` or `"fleiss"`.
#' @return The asymptotic variance for the kappas.
avar <- function(mat, mu, sigma, type = c("cohen", "fleiss")) {
  type <- match.arg(type)
  r <- nrow(sigma)
  y <- sum(diag(sigma))
  x <- sum(sigma) - y
  z <- mean(mu^2) - mean(mu)^2

  vec <- if (type == "fleiss") {
    mult <- 1 / ((r - 1) * (r * z + y)^2)
    c(
      (r * z + y),
      r * z - x,
      -r * (x + y)
    )
  } else {
    mult <- 1 / (r^2 * z + (r - 1) * y)^2
    c(
      r^2 * z + (r - 1) * y,
      -(r - 1) * x,
      -r^2 * x
    )
  }

  c(t(vec) %*% mat %*% vec) * mult^2
}

#' Estimate gamma matrix.
#'
#' The option `"non-parametric"` requires every selection of four raters
#'   to have at least two rows of ratings.
#'
#' @param x Data with potentially missing values.
#' @param type One of `"non-parametric`, `"normal`, and `"elliptical`.
#' @param sigma Optional
#' @return An estimate of gamma.
gamma_est <- function(x, type, sigma) {
  type <- match.arg(type)
  if (type == "non-parametric") stop("Option 'non-parametric' not implemented.")
  if (type == "normal") {
    gamma_mat(sigma, vech = TRUE)
  } else if (type == "elliptical") {
    gamma <- gamma_mat(sigma, vech = TRUE)
    m <- mean(x, na.rm = TRUE)
    kurt <- mean((x - m)^4, na.rm = TRUE) / (mean((x - m)^2, na.rm = TRUE)^2)
    v <- matrixcalc::vec(sigma)
    r <- nrow(sigma)
    e_mat <- matrixcalc::elimination.matrix(r)
    (1 + kurt / 3) * gamma + kurt / 3 * e_mat %*% v %*% t(v) %*% t(e_mat)
  }
}
